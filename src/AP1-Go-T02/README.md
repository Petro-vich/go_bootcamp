Проект «Конкурентное выполнение»
Задание 1. Секундомер асинхронных задач
Программа считывает из аргументов запуска команды N и M.
Параметры N и M задаются через аргументы при запуске программы.
Программа запускает N горутин, каждая из которых спит (time.Sleep) рандомное время до M миллисекунд.
Программа дожидается завершения всех горутин.
Программа выводит в консоль список, состоящий из пар <номер горутины, время сна>, отсортированный в порядке убывания.
Номер горутины — итерация цикла, в которой запущена горутина.
Время сна — количество миллисекунд сна.
НЕ допускается использование каналов.

Подсказка: используй пакет sync. Для начала вывода необходимо дождаться завершения всех горутин. Используй пакет flag.

Задание 2. Генератор квадратов числа
Программа считывает из аргументов запуска команды K и N.
Параметры K и N задаются через аргументы при вызове программы.
Программа запускает 2 функции: генератор, и функцию возведения в квадрат.
Параметры N и M имеют тип int.
Функция генератор запускает горутину и возвращает канал 1. Внутри горутины генерируются числа от K до N (включительно) и отправляются в канал 1.
Функция возведения в квадрат запускает горутину и возвращает канал 2. Внутри горутины вычитываются числа из канала 1, каждое возводится в квадрат, результат отправляется в канал 2.
Основная программа (main) вычитывает числа из канала 2 и печатает его в консоль.
Функция возведения в квадрат должна принимать канал 1 на чтение, полученный из функции генератор.
Возведение в квадрат и генератор должны быть запущены конкурентно.
Возведение числа в квадрат должно происходить последовательно. После чтения числа из канала 1 его необходимо сразу возводить в квадрат и отправлять дальше, и после этого обрабатывать другое число.
Подсказка: каналы необходимо создавать в функциях, возвращать канал с ограничением на операцию чтения/записи. Каналы необходимо закрывать после завершения работы функции. Функции генератор и возведения в квадрат должны работать конкурентно.

Задание 3. Тикер
Программа считывает из аргументов запуска команды параметр K.
Параметр K задаётся через аргументы при вызове программы.
K задаёт шаг тикера в секундах и имеет тип Int.
Программа выводит в stdout сообщение «Tick <i> since <time>», где <i> — номер тика, а <time> — время, прошедшее с начала запуска тикера в секундах.
Программа работает до тех пор, пока пользователь не отправит программе сигналы SIGTERM или SIGINT.
После получения одного из сигналов программа завершает тикер и выводит сообщение «Termination».
Тикер работает асинхронно, запрещено использовать функции пакета time (например, time.After или time.Ticker). Допускается использование констант из пакета time, и функцию Sleep.
Подсказка: используй константы для сигналов из пакета os, а также функцию signal.Notify для работы с сигналами.

Бонусное задание 4. LRU-Cache с использованием Generics
Необходимо реализовать пакет, содержащий структуру Cache, использующую алгоритм LRU.
Необходима функция-конструктор, которая принимает тип элементов и ёмкость, возвращает указатель на структуру Cache.
Cache имеет следующие методы:
a. Set — добавить элемент с определённым ключом;
b. Get — получить элемент по определённому ключу;
c. Clear — удаление всех элементов в кэше.
Сложность операций Set и Get должна быть О(1).

Логика LRU.

При добавлении:

Если элемент присутствует в кэше, то его позиция изменится на начальную.
Если элемента нет и ёмкость не превышена, то он будет добавлен в начало.
Если элемента нет и ёмкость превышена, то он будет добавлен в начало, а последний элемент будет удалён.
При получении:

Если элемент присутствует, то он будет передвинут в начало и возвращён пользователю с дополнительным аргументом true.
Если элемент отсутствует, то пользователю будет возвращён zero-value для данного типа и дополнительный аргумент false.
Cache должен работать только с тем типом элементов, который задан при вызове функции-конструктора (используй golang generics).

Cache должен быть потокобезопасным, это значит, что обращение к Cache из разных горутин не породит состояние гонки.

Необходимо реализовать тесты для проверки сценариев:

Редко используемые элементы удаляются из кэша.
При превышении ёмкости кэша редко используемые элементы будут удалены.